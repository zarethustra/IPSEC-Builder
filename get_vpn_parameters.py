#!/usr/bin/env python3
"""
ASA IPsec VPN Command Generator (IKEv2)

Prompts for variables and outputs a ready-to-paste ASA configuration block.
Includes validation for IP addresses, subnets, and basic naming hygiene.

Author: Generated by M365 Copilot
"""
import ipaddress
import re
from pathlib import Path

TEMPLATE = """
! === Base crypto (IKEv2/IPsec) ===
crypto ipsec ikev2 ipsec-proposal AES256-SHA256
 protocol esp encryption aes-256
 protocol esp integrity sha-256
crypto ikev2 policy 5
 encryption aes-256
 integrity sha256
 group 14
 prf sha256
 lifetime seconds 86400

! === Objects and ACLs for {DESTINATION} ===
object-group network VPN-{DESTINATION}-LOCAL
 network-object {LOCAL_IP} {LOCAL_MASK}
object-group network VPN-{DESTINATION}-REMOTE
 network-object {REMOTE_IP} {REMOTE_MASK}
access-list TO-{DESTINATION}-VPN extended permit ip object-group VPN-{DESTINATION}-LOCAL object-group VPN-{DESTINATION}-REMOTE

! === NAT exemption ===
nat (Inside,Outside) source static VPN-{DESTINATION}-LOCAL VPN-{DESTINATION}-LOCAL destination static VPN-{DESTINATION}-REMOTE VPN-{DESTINATION}-REMOTE no-proxy-arp route-lookup

! === Crypto map and peer ===
crypto map outside_map {VPN_NUMBER} match address TO-{DESTINATION}-VPN
crypto map outside_map {VPN_NUMBER} set peer {PEERIP}
crypto map outside_map {VPN_NUMBER} set ikev2 ipsec-proposal AES256-SHA256
crypto map outside_map {VPN_NUMBER} set security-association lifetime seconds 28800

! === Tunnel-group ===
tunnel-group {PEERIP} type ipsec-l2l
! tunnel-group {PEERIP} general-attributes
! default-group-policy DEFAULT-IKEv2

tunnel-group {PEERIP} ipsec-attributes
 ikev2 remote-authentication pre-shared-key {PSK}
 ikev2 local-authentication pre-shared-key {PSK}
"""


def sanitize_name(name: str) -> str:
    """Allow only alphanumerics and dashes/underscores in DESTINATION label."""
    cleaned = re.sub(r"[^A-Za-z0-9_-]", "-", name.strip())
    return cleaned.upper()


def parse_network(cidr_or_ip_mask: str):
    """Accept input as CIDR (e.g., 10.1.2.0/24) or IP + mask (e.g., 10.1.2.0 255.255.255.0).
    Returns (ip, mask) strings suitable for ASA 'network-object <IP> <MASK>'.
    Raises ValueError on invalid input.
    """
    s = cidr_or_ip_mask.strip()
    parts = s.split()
    if len(parts) == 2:
        ip_str, mask_str = parts
        # Validate dotted-decimal mask by converting to IPv4Network with strict=False
        try:
            # Convert mask to prefix by creating a network with this mask
            ipaddress.IPv4Address(ip_str)  # validates IP
            # Validate mask by checking it's a valid netmask (must match a network mask)
            # Try to construct network using ip/mask
            _ = ipaddress.IPv4Network(f"{ip_str}/{mask_str}", strict=False)
        except Exception as e:
            raise ValueError(f"Invalid IP/mask '{ip_str} {mask_str}': {e}")
        return ip_str, mask_str
    else:
        # Expect CIDR notation
        try:
            net = ipaddress.IPv4Network(s, strict=True)
        except Exception as e:
            raise ValueError(f"Invalid CIDR '{s}': {e}")
        # Convert to ip + mask (network address + dotted netmask)
        return str(net.network_address), str(net.netmask)


def validate_peer_ip(peer: str) -> str:
    try:
        return str(ipaddress.IPv4Address(peer.strip()))
    except Exception as e:
        raise ValueError(f"Invalid PEERIP '{peer}': {e}")


def validate_vpn_number(num_str: str) -> int:
    try:
        n = int(num_str)
    except Exception:
        raise ValueError("VPN number must be an integer")
    if n < 1 or n > 65535:
        raise ValueError("VPN number must be between 1 and 65535")
    return n


def generate_commands(destination: str, local: str, remote: str, peerip: str, psk: str, vpn_number: int) -> str:
    dest = sanitize_name(destination)
    local_ip, local_mask = parse_network(local)
    remote_ip, remote_mask = parse_network(remote)
    peer = validate_peer_ip(peerip)
    if not psk or psk.strip() == "":
        raise ValueError("Pre-shared key cannot be empty")
    return TEMPLATE.format(
        DESTINATION=dest,
        LOCAL_IP=local_ip,
        LOCAL_MASK=local_mask,
        REMOTE_IP=remote_ip,
        REMOTE_MASK=remote_mask,
        PEERIP=peer,
        PSK=psk,
        VPN_NUMBER=vpn_number,
    ).strip() + "\n"


def main():
    print("=== ASA IPsec VPN Command Generator (IKEv2) ===")
    destination = input("DESTINATION label (e.g., BRANCH01): ").strip()
    local = input("LOCAL_NETWORK (CIDR or 'IP MASK', e.g., 10.0.0.0/24 or 10.0.0.0 255.255.255.0): ").strip()
    remote = input("REMOTE_NETWORK (CIDR or 'IP MASK'): ").strip()
    peerip = input("PEERIP (IPv4 address): ").strip()
    psk = input("PRE_SHARED_KEY: ").strip()
    vpn_number_str = input("VPN number (next available): ").strip()

    try:
        vpn_number = validate_vpn_number(vpn_number_str)
        commands = generate_commands(destination, local, remote, peerip, psk, vpn_number)
    except Exception as e:
        print(f"\n[ERROR] {e}")
        return

    print("\n--- Generated ASA Configuration ---\n")
    print(commands)

    # Offer to save
    save = input("Save to file? (y/N): ").strip().lower()
    if save == 'y':
        out_name = f"asa_vpn_{sanitize_name(destination)}.txt"
        Path(out_name).write_text(commands)
        print(f"\nSaved to {out_name}")

if __name__ == "__main__":
    main()
